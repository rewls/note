= 2 Programming with GNU History
:toc: left

* This chapter describes how to interface programs that you write with the GNU
  History Library.
* It should be considered a technical guide.
* For information on the interactive use of GNU History, see Using History
  Interactively.

== 2.1 Introduction to History

* Many programs read input from the user a line at a time.
* The GNU History library is able to keep track of those lines, associate
  arbitrary data with each line, and utilize information from previous lines
  when composing new ones.

'''

* A programmer using the History library can use functions to save commands on
  a history list, associate arbitrary data with history list entries, remove
  entries from the list, search through the list for a line containing an
  arbitrary text string, reference any entry in the list directly, and read
  and write the history list from and to a file.
* In addition, a history expansion function is available which provides for a
  consistent user interface across different programs.

'''

* Someone using programs written with the History library has the benefit of a
  consistent user interface with a set of well-known commands for manipulating
  the text of previous lines and using that text in new commands.
* The basic history manipulation commands are similar to the history
  substitution provided by `csh`.

'''

* The programmer can also use the Readline library, which includes some
  history manipulation by default, and has the added advantage of command line
  editing.

'''

* Before declaring any functions using any functionality the History library
  provides in other code, an application writer should include the file
  `<readline/history.h>` in any file that uses the History library's features.
* It supplies declarations for all of the library's public functions and
  variables, and declares all of the public data structures.

== 2.2 History Storage

* The history list is an array of history entries.
* A history entry is declared as follows:
+
[,c]
----
typedef void *histdata_t;

typedef struct _hist_entry {
  char *line;
  char *timestamp;
  histdata_t data;
} HIST_ENTRY;
----

* The history list itself might therefore be declared as
+
[source,c]
HIST_ENTRY **the_history_list;

* The state of the History library is encapsulated into a single structure:

[,c]
----
/*
 * A structure used to pass around the current state of the history.
 */
typedef struct _hist_state {
  HIST_ENTRY **entries; /* Pointer to the entries themselves. */
  int offset;           /* The location pointer within this array. */
  int length;           /* Number of elements within this array. */
  int size;             /* Number of slots allocated to this array. */
  int flags;
} HISTORY_STATE;
----

* If the flags member includes `HS_STIFLED`, the history has been stifled
  (limited to a maximum number of entries).

== 2.3 History Functions

* This section describes the calling sequence for the various functions
  exported by the GNU History library.

=== 2.3.2 History List Management

* These functions manage individual entries on the history list, or set
  parameters managing the list itself.

.Function: `void *add_history* (const char *string)`
* Add _string_ to the end of the history list, and set the associated data
  field (if any) to `NULL`.
* If the maximum number of history entries has been set using
  `stifle_history()`, and the new number of history entries would exceed that
  maximum, this removes the oldest history entry.

.Function: `void *clear_history* (void)`
* Clear the history list by deleting all the entries.
