= 2 Programming with GNU Readline
:source-highlighter: rouge
:tabsize: 8
:toc: left

* This chapter describes the interface between the GNU Readline Library and
  other programs.
* If you are a programmer, and you wish to include the features found in GNU
  Readline such as completion, line editing, and interactive history
  manipulation in your own programs, this section is for you.

== 2.1 Basic Behavior

* Many programs provide a command line interface, such as mail, ftp, and sh.
* For such programs, the default behavior of Readline is sufficient.
* This section describes how to use Readline in the simplest way possible,
  perhaps to replace calls in your code to `fgets()`.

'''

* The function `readline()` prints a prompt _prompt_ and then reads and
  returns a single line of text from the user.
* Since it's possible to enter characters into the line while quoting them to
  disable any Readline editing function they might normally have, this line
  may include embedded newlines and other special characters.
* If _prompt_ is `NULL` or the empty string, `readline()` does not display a
  prompt.
* The line `readline()` returns is allocated with `malloc()`; the caller
  should `free()` the line when it has finished with it.
* The declaration for `readline` in ANSI C is
+
[source,c,subs="macros+"]
char *readline (const char *pass:q[_prompt_]);

* So, one might say
+
[source,c]
char *line = readline ("Enter a line: ");
+
in order to read a line of text from the user.
* The line returned has the final newline removed, so only the text remains.
* This means that lines consisting of a newline return the empty string.

'''

* If Readline encounters an `EOF` while reading the line, and the line is
  empty at that point, then `readline()` returns `(char *)NULL`.
* Otherwise, the line is ended just as if a newline had been typed.

'''

* Readline performs some expansion on the prompt before it is displayed on the
  screen.
* See the description of `rl_expand_prompt` (see Redisplay) for additional
  details, especially if _prompt_ will contain characters that do not consume
  physical screen space when displayed.

'''

* If you want the user to be able to get at the line later, (with `C-p` for
  example), you must call `add_history()` to save the line away in a history
  list of such lines.

[source,c]
add_history (line);

* For full details on the GNU History Library, see the associated manual.

'''

* It is preferable to avoid saving empty lines on the history list, since
  users rarely have a burning need to reuse a blank line.
* Here is a function which usefully replaces the standard `gets()` library
  function, and has the advantage of no static buffer to overflow:

[,c]
----
/* A static variable for holding the line. */
static char *line_read = (char *)NULL;

/* Read a string, and return a pointer to it.
   Returns NULL on EOF. */
char *
rl_gets ()
{
  /* If the buffer has already been allocated,
     return the memory to the free pool. */
  if (line_read)
    {
      free (line_read);
      line_read = (char *)NULL;
    }

  /* Get a line from the user. */
  line_read = readline ("");

  /* If the line has any text in it,
     save it on the history. */
  if (line_read && *line_read)
    add_history (line_read);

  return (line_read);
}
----

* This function gives the user the default behavior of `TAB` completion:
  filename completion.
* If you do not want Readline to complete filenames, you can change the
  binding of the `TAB` key with `rl_bind_key()`.

[source,c,subs="macros+"]
int rl_bind_key (int pass:q[_key_], rl_command_func_t *pass:q[_function_]);

* `rl_bind_key()` takes two arguments: _key_ is the character that you want to
  bind, and _function_ is the address of the function to call when _key_ is
  pressed.
* Binding `TAB` to `rl_insert()` makes `TAB` insert itself.
* `rl_bind_key()` returns non-zero if key is not a valid ASCII character code
  (between 0 and 255).

'''

* Thus, to disable the default `TAB` behavior, the following suffices:
+
[source,c]
rl_bind_key ('\t', rl_insert);

* This code should be executed once at the start of your program; you might
  write a function called `initialize_readline()` which performs this and
  other desired initializations, such as installing custom completers (see
  Custom Completers).

== 2.3 Readline Variables

* These variables are available to function writers.

.Variable: `char * *rl_line_buffer*`
* This is the line gathered so far.
* You are welcome to modify the contents of the line, but see Allowing
  Undoing.
* The function `rl_extend_line_buffer` will increase the memory allocated to
  `rl_line_buffer`.

== 2.4 Readline Convenience Functions

=== 2.4.6 Redisplay

.Function: `void *rl_redisplay* (void)`
* Change what's displayed on the screen to reflect the current contents of
  `rl_line_buffer`.

.Function: `int *rl_on_new_line* (void)`
* Tell the update functions that we have moved onto a new (empty) line,
  usually after outputting a newline.

=== 2.4.7 Modifying Text

.Function: `void *rl_replace_line* (const char *text, int clear_undo)`
* Replace the contents of `rl_line_buffer` with text.
* This preserves the point and mark, if possible.
* If `clear_undo` is non-zero, this clears the undo list associated with the
  current line.

=== 2.4.11 Miscellaneous Functions

.Function: `void *rl_clear_history*(void)`
* Clear the history list by deleting all of the entries, in the same manner as
  the History library's `clear_history()` function.
* This differs from `clear_history` because it frees private data Readline
  saves in the history list.

=== 2.4.13 A Readline Example

* Here is a function which changes lowercase characters to their uppercase
  equivalents, and uppercase characters to lowercase.
* If this function was bound to '```M-c```', then typing '```M-c```' would
  change the case of the character under point.
* Typing '```M-1 0 M-c```' would change the case of the following 10
  characters, leaving the cursor on the last character changed.

[,c]
----
/* Invert the case of the COUNT following characters. */
int
invert_case_line (count, key)
     int count, key;
{
  int start, end, i;

  start = rl_point;

  if (rl_point >= rl_end)
    return (0);

  /* Find the end of the range to modify. */
  end = start + count;

  /* Force it to be within range. */
  if (end > rl_end)
    end = rl_end;
  else if (end < 0)
    end = 0;

  if (start == end)
    return (0);

  /* For positive arguments, put point after the last changed character. For
     negative arguments, put point before the last changed character. */
  rl_point = end;

  /* Swap start and end if we are moving backwards */
  if (start > end)
    {
      int temp = start;
      start = end;
      end = temp;
    }

  /* Tell readline that we are modifying the line,
     so it will save the undo information. */
  rl_modifying (start, end);

  for (i = start; i != end; i++)
    {
      if (_rl_uppercase_p (rl_line_buffer[i]))
        rl_line_buffer[i] = _rl_to_lower (rl_line_buffer[i]);
      else if (_rl_lowercase_p (rl_line_buffer[i]))
        rl_line_buffer[i] = _rl_to_upper (rl_line_buffer[i]);
    }

  return (0);
}
----
