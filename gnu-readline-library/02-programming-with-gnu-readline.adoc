= 2 Programming with GNU Readline
:source-highlighter: rouge
:tabsize: 8
:toc: left

* This chapter describes the interface between the GNU Readline Library and
  other programs.
* If you are a programmer, and you wish to include the features found in GNU
  Readline such as completion, line editing, and interactive history
  manipulation in your own programs, this section is for you.

== 2.1 Basic Behavior

* Many programs provide a command line interface, such as mail, ftp, and sh.
* For such programs, the default behavior of Readline is sufficient.
* This section describes how to use Readline in the simplest way possible,
  perhaps to replace calls in your code to `fgets()`.

'''

* The function `readline()` prints a prompt _prompt_ and then reads and
  returns a single line of text from the user.
* Since it's possible to enter characters into the line while quoting them to
  disable any Readline editing function they might normally have, this line
  may include embedded newlines and other special characters.
* If _prompt_ is `NULL` or the empty string, `readline()` does not display a
  prompt.
* The line `readline()` returns is allocated with `malloc()`; the caller
  should `free()` the line when it has finished with it.
* The declaration for `readline` in ANSI C is
+
[source,c,subs="macros+"]
char *readline (const char *pass:q[_prompt_]);

* So, one might say
+
[source,c]
char *line = readline ("Enter a line: ");
+
in order to read a line of text from the user.
* The line returned has the final newline removed, so only the text remains.
* This means that lines consisting of a newline return the empty string.

'''

* If Readline encounters an `EOF` while reading the line, and the line is
  empty at that point, then `readline()` returns `(char *)NULL`.
* Otherwise, the line is ended just as if a newline had been typed.

'''

* Readline performs some expansion on the prompt before it is displayed on the
  screen.
* See the description of `rl_expand_prompt` (see Redisplay) for additional
  details, especially if _prompt_ will contain characters that do not consume
  physical screen space when displayed.

'''

* If you want the user to be able to get at the line later, (with `C-p` for
  example), you must call `add_history()` to save the line away in a history
  list of such lines.

[source,c]
add_history (line);

* For full details on the GNU History Library, see the associated manual.

'''

* It is preferable to avoid saving empty lines on the history list, since
  users rarely have a burning need to reuse a blank line.
* Here is a function which usefully replaces the standard `gets()` library
  function, and has the advantage of no static buffer to overflow:

[,c]
----
/* A static variable for holding the line. */
static char *line_read = (char *)NULL;

/* Read a string, and return a pointer to it.
   Returns NULL on EOF. */
char *
rl_gets ()
{
  /* If the buffer has already been allocated,
     return the memory to the free pool. */
  if (line_read)
    {
      free (line_read);
      line_read = (char *)NULL;
    }

  /* Get a line from the user. */
  line_read = readline ("");

  /* If the line has any text in it,
     save it on the history. */
  if (line_read && *line_read)
    add_history (line_read);

  return (line_read);
}
----

* This function gives the user the default behavior of `TAB` completion:
  filename completion.
* If you do not want Readline to complete filenames, you can change the
  binding of the `TAB` key with `rl_bind_key()`.

[source,c,subs="macros+"]
int rl_bind_key (int pass:q[_key_], rl_command_func_t *pass:q[_function_]);

* `rl_bind_key()` takes two arguments: _key_ is the character that you want to
  bind, and _function_ is the address of the function to call when _key_ is
  pressed.
* Binding `TAB` to `rl_insert()` makes `TAB` insert itself.
* `rl_bind_key()` returns non-zero if key is not a valid ASCII character code
  (between 0 and 255).

'''

* Thus, to disable the default `TAB` behavior, the following suffices:
+
[source,c]
rl_bind_key ('\t', rl_insert);

* This code should be executed once at the start of your program; you might
  write a function called `initialize_readline()` which performs this and
  other desired initializations, such as installing custom completers (see
  Custom Completers).

== 2.3 Readline Variables

* These variables are available to function writers.

.Variable: `char * *rl_line_buffer*`
* This is the line gathered so far.
* You are welcome to modify the contents of the line, but see Allowing
  Undoing.
* The function `rl_extend_line_buffer` will increase the memory allocated to
  `rl_line_buffer`.

.Variable: `int *rl_done*`
* Setting this to a non-zero value causes Readline to return the current line
  immediately.
* Readline will set this variable when it has read a key sequence bound to
  accept-line and is about to return the line to the caller.

.Variable: `int *rl_already_prompted*`
* If an application wishes to display the prompt itself, rather than have
  Readline do it the first time `readline()` is called, it should set this
  variable to a non-zero value after displaying the prompt.
* The prompt must also be passed as the argument to `readline()` so the
  redisplay functions can update the display properly.
* The calling application is responsible for managing the value; Readline
  never sets it.

.Variable: `rl_hook_func_t * *rl_event_hook*`
* If non-zero, this is the address of a function to call periodically when
  Readline is waiting for terminal input.
* By default, this will be called at most ten times a second if there is no
  keyboard input.

.Variable: `rl_voidfunc_t * *rl_redisplay_function*`
* Readline will call indirectly through this pointer to update the display
  with the current contents of the editing buffer.
* By default, it is set to `rl_redisplay`, the default Readline redisplay
  function (see Redisplay).

== 2.4 Readline Convenience Functions

=== 2.4.6 Redisplay

.Function: `void *rl_redisplay* (void)`
* Change what's displayed on the screen to reflect the current contents of
  `rl_line_buffer`.

.Function: `int *rl_on_new_line* (void)`
* Tell the update functions that we have moved onto a new (empty) line,
  usually after outputting a newline.

=== 2.4.7 Modifying Text

.Function: `void *rl_replace_line* (const char *text, int clear_undo)`
* Replace the contents of `rl_line_buffer` with text.
* This preserves the point and mark, if possible.
* If `clear_undo` is non-zero, this clears the undo list associated with the
  current line.

=== 2.4.11 Miscellaneous Functions

.Function: `void *rl_clear_history*(void)`
* Clear the history list by deleting all of the entries, in the same manner as
  the History library's `clear_history()` function.
* This differs from `clear_history` because it frees private data Readline
  saves in the history list.

=== 2.4.13 A Readline Example

* Here is a function which changes lowercase characters to their uppercase
  equivalents, and uppercase characters to lowercase.
* If this function was bound to '```M-c```', then typing '```M-c```' would
  change the case of the character under point.
* Typing '```M-1 0 M-c```' would change the case of the following 10
  characters, leaving the cursor on the last character changed.

[,c]
----
/* Invert the case of the COUNT following characters. */
int
invert_case_line (count, key)
     int count, key;
{
  int start, end, i;

  start = rl_point;

  if (rl_point >= rl_end)
    return (0);

  /* Find the end of the range to modify. */
  end = start + count;

  /* Force it to be within range. */
  if (end > rl_end)
    end = rl_end;
  else if (end < 0)
    end = 0;

  if (start == end)
    return (0);

  /* For positive arguments, put point after the last changed character. For
     negative arguments, put point before the last changed character. */
  rl_point = end;

  /* Swap start and end if we are moving backwards */
  if (start > end)
    {
      int temp = start;
      start = end;
      end = temp;
    }

  /* Tell readline that we are modifying the line,
     so it will save the undo information. */
  rl_modifying (start, end);

  for (i = start; i != end; i++)
    {
      if (_rl_uppercase_p (rl_line_buffer[i]))
        rl_line_buffer[i] = _rl_to_lower (rl_line_buffer[i]);
      else if (_rl_lowercase_p (rl_line_buffer[i]))
        rl_line_buffer[i] = _rl_to_upper (rl_line_buffer[i]);
    }

  return (0);
}
----

== 2.5 Readline Signal Handling

* Signals are asynchronous events sent to a process by the Unix kernel,
  sometimes on behalf of another process.
* They are intended to indicate exceptional events, like a user pressing the
  terminal's interrupt key, or a network connection being broken.
* There is a class of signals that can be sent to the process currently
  reading input from the keyboard.
* Since Readline changes the terminal attributes when it is called, it needs
  to perform special processing when such a signal is received in order to
  restore the terminal to a sane state, or provide applications using Readline
  with functions to do so manually.

'''

* Readline contains an internal signal handler that is installed for a number
  of signals (`SIGINT`, `SIGQUIT`, `SIGTERM`, `SIGHUP`, `SIGALRM`, `SIGTSTP`,
  `SIGTTIN`, and `SIGTTOU`).
* When Readline receives one of these signals, the signal handler will reset
  the terminal attributes to those that were in effect before `readline()` was
  called, reset the signal handling to what it was before `readline()` was
  called, and resend the signal to the calling application.
* If and when the calling application's signal handler returns, Readline will
  reinitialize the terminal and continue to accept input.
* When a `SIGINT` is received, the Readline signal handler performs some
  additional work, which will cause any partially-entered line to be aborted
  (see the description of `rl_free_line_state()` below).

'''

* There is an additional Readline signal handler, for `SIGWINCH`, which the
  kernel sends to a process whenever the terminal's size changes (for example,
  if a user resizes an `xterm`).
* The Readline `SIGWINCH` handler updates Readline's internal screen size
  information, and then calls any `SIGWINCH` signal handler the calling
  application has installed.
* Readline calls the application's `SIGWINCH` signal handler without resetting
  the terminal to its original state.
* If the application's signal handler does more than update its idea of the
  terminal size and return (for example, a `longjmp` back to a main processing
  loop), it must call `rl_cleanup_after_signal()` (described below), to restore
  the terminal state.

'''

* When an application is using the callback interface (see Alternate
  Interface), Readline installs signal handlers only for the duration of the
  call to `rl_callback_read_char`.
* Applications using the callback interface should be prepared to clean up
  Readline's state if they wish to handle the signal before the line handler
  completes and restores the terminal state.

'''

* If an application using the callback interface wishes to have Readline
  install its signal handlers at the time the application calls
  `rl_callback_handler_install` and remove them only when a complete line of
  input has been read, it should set the `rl_persistent_signal_handlers`
  variable to a non-zero value.
* This allows an application to defer all of the handling of the signals
  Readline catches to Readline.
* Applications should use this variable with care; it can result in Readline
  catching signals and not acting on them (or allowing the application to
  react to them) until the application calls `rl_callback_read_char`.
* This can result in an application becoming less responsive to keyboard
  signals like `SIGINT`.
* If an application does not want or need to perform any signal handling, or
  does not need to do any processing between calls to `rl_callback_read_char`,
  setting this variable may be appropriate.

'''

* Readline provides two variables that allow application writers to control
  whether or not it will catch certain signals and act on them when they are
  received.
* It is important that applications change the values of these variables only
  when calling `readline()`, not in a signal handler, so Readline's internal
  signal state is not corrupted.
